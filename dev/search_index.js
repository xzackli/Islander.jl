var documenterSearchIndex = {"docs":
[{"location":"#Islander.jl-1","page":"Home","title":"Islander.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Modules = [Islander]\nOrder   = [:type, :function]\nPages   = [\"Islander.jl\", \"Pixell.jl\"]","category":"page"},{"location":"#Islander.Enmap","page":"Home","title":"Islander.Enmap","text":"Map type, contains an AbstractArray and a WCS object, but behaves like the AbstractArray it contains for array operations.\n\nIt does not implement many Base Array operations, under the assumption that you probably will not want to do an LU decomposition on a map when you type m1/m2. You should work with the data directly enmap_object.data if you need additional Array functions.\n\n\n\n\n\n","category":"type"},{"location":"#Islander.car-Tuple{Any,Any,Any}","page":"Home","title":"Islander.car","text":"Generate a plate carree WCS object.\n\npixell python reference:\n\npos :\ndef car(pos, res=None, shape=None, rowmajor=False, ref=None):\n\tpos, res, shape, mid = validate(pos, res, shape, rowmajor)\n\tw = WCS(naxis=2)\n\tw.wcs.ctype = [\"RA---CAR\", \"DEC--CAR\"]\n\tw.wcs.crval = np.array([mid[0],0])\n\tif ref is \"standard\": ref = (0,0)\n\treturn finalize(w, pos, res, shape, ref=ref)\n\n\n\n\n\n","category":"method"},{"location":"#","page":"Home","title":"Home","text":"Islander will be a nice component separation code someday!","category":"page"}]
}
